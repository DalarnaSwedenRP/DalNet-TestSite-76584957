<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WindCode 2D Prototype</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        #codeWindow {
            width: 50%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
            background-color: #f0f0f0;
        }
        #codeInput {
            width: 100%;
            height: 80%;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            resize: none;
            border: 1px solid #ccc;
        }
        #runButton {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #canvasWindow {
            width: 50%;
            height: 100%;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="codeWindow">
        <textarea id="codeInput" placeholder="Skriv din WindCode här, t.ex.:\nlocal block1\nplace('block', 50, 50, 0, 100, 100, 0)\ncolor: red;\nend\nlocal sphere1\nplace('sphere', 200, 200, 0, 50, 50, 0)\ncolor: blue;\nend\nlocal text1\ntext('Hello World', 150, 150, 0, 250, 50, 0)\nfont: Times New Roman;\ncolor: green;\nend\nlocal image1\nimage(20, 20, 0, 100, 100, 0)\nurl: https://picsum.photos/100/100;\ntransparency: 0.5;\nend\nloop(3) {\n  local block2\n  place('block', 300, 300, 0, 50, 50, 0)\n  color: yellow;\n  end\n}\nif(100 > 50) {\n  local text2\n  text('Condition met', 100, 400, 0, 250, 30, 0)\n  font: Courier New;\n  color: purple;\n  end\n}\nlocate\nmove(100, 100, 0, 150, 150, 0)\nobjekt: block1;\nend"></textarea>
        <button id="runButton">Kör kod</button>
    </div>
    <div id="canvasWindow">
        <canvas id="renderCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth / 2;
        canvas.height = window.innerHeight;

        // Lagring av objekt
        const objects = [];

        // Funktion för att tolka och köra WindCode
        function runWindCode(code) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            objects.length = 0; // Rensa tidigare objekt
            const lines = code.split('\n').map(line => line.trim()).filter(line => line);
            let currentObject = null;
            let currentName = null;
            let currentColor = 'white';
            let currentUrl = null;
            let currentTransparency = 1;
            let currentFont = 'Arial';
            let expectingLocal = true;
            let expectingColor = false;
            let expectingUrl = false;
            let expectingTransparency = false;
            let expectingFont = false;
            let expectingEnd = false;
            let expectingObjekt = false;
            let loopCount = 0;
            let loopIterations = 0;
            let loopStartIndex = -1;
            let loopBody = [];
            let ifCondition = false;
            let ifStartIndex = -1;
            let ifBody = [];

            function evaluateCondition(condition) {
                const match = condition.match(/(\d+)\s*(>|>=|<|<=|==|!=)\s*(\d+)/);
                if (!match) return false;
                const [, left, op, right] = match;
                const leftNum = parseInt(left);
                const rightNum = parseInt(right);
                if (op === '>') return leftNum > rightNum;
                if (op === '>=') return leftNum >= rightNum;
                if (op === '<') return leftNum < rightNum;
                if (op === '<=') return leftNum <= rightNum;
                if (op === '==') return leftNum === rightNum;
                if (op === '!=') return leftNum !== rightNum;
                return false;
            }

            function drawObject(obj) {
                ctx.fillStyle = obj.color || 'white';
                ctx.globalAlpha = obj.transparency || 1;
                if (obj.type === 'block') {
                    ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                } else if (obj.type === 'sphere') {
                    ctx.beginPath();
                    ctx.arc(obj.x + obj.width / 2, obj.y + obj.height / 2, obj.width / 2, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (obj.type === 'text') {
                    ctx.font = `${obj.height}px ${obj.font || 'Arial'}`;
                    ctx.fillText(obj.text, obj.x, obj.y + obj.height);
                } else if (obj.type === 'image' && obj.url) {
                    const img = new Image();
                    img.crossOrigin = 'Anonymous';
                    img.onload = () => {
                        ctx.globalAlpha = obj.transparency;
                        ctx.drawImage(img, obj.x, obj.y, obj.width, obj.height);
                        ctx.globalAlpha = 1;
                    };
                    img.onerror = () => {
                        ctx.fillStyle = 'red';
                        ctx.font = '20px Arial';
                        ctx.fillText('Failed to load image: ' + obj.name, 10, 50);
                    };
                    img.src = obj.url;
                }
                ctx.globalAlpha = 1;
            }

            function executeLines(start, end, offsetX = 0, offsetY = 0) {
                let i = start;
                while (i < end) {
                    const line = lines[i];

                    if (expectingLocal && line.startsWith('local ')) {
                        const nameMatch = line.match(/local\s+(\w+)/);
                        if (nameMatch && !objects.find(obj => obj.name === nameMatch[1])) {
                            currentName = nameMatch[1];
                            expectingLocal = false;
                            i++;
                            continue;
                        }
                    }

                    if (!expectingLocal && line.startsWith('place(')) {
                        const params = line.match(/place\("([^"]+)",\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)\)/);
                        if (params) {
                            const [, type, x, y, , width, height] = params;
                            currentObject = { name: currentName, type, x: parseInt(x) + offsetX, y: parseInt(y) + offsetY, width: parseInt(width), height: parseInt(height) };
                            expectingColor = true;
                            i++;
                            continue;
                        }
                    }

                    if (!expectingLocal && line.startsWith('text(')) {
                        const params = line.match(/text\("([^"]+)",\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)\)/);
                        if (params) {
                            const [, text, x, y, , width, height] = params;
                            currentObject = { name: currentName, type: 'text', text, x: parseInt(x) + offsetX, y: parseInt(y) + offsetY, width: parseInt(width), height: parseInt(height) };
                            expectingFont = true;
                            i++;
                            continue;
                        }
                    }

                    if (!expectingLocal && line.startsWith('image(')) {
                        const params = line.match(/image\((\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)\)/);
                        if (params) {
                            const [, x, y, , width, height] = params;
                            currentObject = { name: currentName, type: 'image', x: parseInt(x) + offsetX, y: parseInt(y) + offsetY, width: parseInt(width), height: parseInt(height) };
                            expectingUrl = true;
                            i++;
                            continue;
                        }
                    }

                    if (expectingFont && line.startsWith('font:')) {
                        const fontMatch = line.match(/font:\s*([^;]+);/);
                        if (fontMatch) {
                            currentFont = fontMatch[1];
                            expectingFont = false;
                            expectingColor = true;
                            i++;
                            continue;
                        }
                    }

                    if (expectingColor && line.startsWith('color:')) {
                        const colorMatch = line.match(/color:\s*(\w+);/);
                        if (colorMatch) {
                            currentColor = colorMatch[1];
                            expectingColor = false;
                            expectingEnd = true;
                            currentObject.color = currentColor;
                            currentObject.font = currentFont;
                            objects.push(currentObject);
                            drawObject(currentObject);
                            i++;
                            continue;
                        }
                    }

                    if (expectingUrl && line.startsWith('url:')) {
                        const urlMatch = line.match(/url:\s*([^;]+);/);
                        if (urlMatch) {
                            currentUrl = urlMatch[1];
                            expectingUrl = false;
                            expectingTransparency = true;
                            i++;
                            continue;
                        }
                    }

                    if (expectingTransparency && line.startsWith('transparency:')) {
                        const transparencyMatch = line.match(/transparency:\s*(\d*\.?\d*);/);
                        if (transparencyMatch) {
                            const transparency = parseFloat(transparencyMatch[1]);
                            if (transparency >= 0 && transparency <= 1) {
                                currentTransparency = transparency;
                                expectingTransparency = false;
                                expectingEnd = true;
                                currentObject.url = currentUrl;
                                currentObject.transparency = currentTransparency;
                                objects.push(currentObject);
                                drawObject(currentObject);
                            } else {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = 'red';
                                ctx.font = '20px Arial';
                                ctx.fillText('Invalid transparency value at line: ' + (i + 1), 10, 50);
                                return;
                            }
                            i++;
                            continue;
                        }
                    }

                    if (expectingEnd && line === 'end') {
                        expectingEnd = false;
                        expectingLocal = true;
                        currentObject = null;
                        currentName = null;
                        currentColor = 'white';
                        currentUrl = null;
                        currentTransparency = 1;
                        currentFont = 'Arial';
                        i++;
                        continue;
                    }

                    if (line === 'locate') {
                        expectingLocal = false;
                        expectingObjekt = true;
                        i++;
                        continue;
                    }

                    if (expectingObjekt && line.startsWith('move(')) {
                        const params = line.match(/move\((\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)\)/);
                        if (params) {
                            const [, x, y, , width, height] = params;
                            currentObject = { x: parseInt(x), y: parseInt(y), width: parseInt(width), height: parseInt(height) };
                            i++;
                            continue;
                        }
                    }

                    if (expectingObjekt && line.startsWith('objekt:')) {
                        const objektMatch = line.match(/objekt:\s*(\w+);/);
                        if (objektMatch) {
                            const objektName = objektMatch[1];
                            const targetObj = objects.find(obj => obj.name === objektName);
                            if (targetObj) {
                                targetObj.x = currentObject.x;
                                targetObj.y = currentObject.y;
                                targetObj.width = currentObject.width;
                                targetObj.height = currentObject.height;
                                expectingObjekt = false;
                                expectingEnd = true;
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                objects.forEach(drawObject);
                            } else {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = 'red';
                                ctx.font = '20px Arial';
                                ctx.fillText('Object not found: ' + objektName, 10, 50);
                                return;
                            }
                            i++;
                            continue;
                        }
                    }

                    if (line.startsWith('loop(')) {
                        const loopMatch = line.match(/loop\((\d+)\)\s*{/);
                        if (loopMatch) {
                            loopIterations = parseInt(loopMatch[1]);
                            loopCount = 0;
                            loopStartIndex = i + 1;
                            loopBody = [];
                            let braceCount = 1;
                            i++;
                            while (i < lines.length && braceCount > 0) {
                                if (lines[i].includes('{')) braceCount++;
                                if (lines[i].includes('}')) braceCount--;
                                if (braceCount > 0) loopBody.push(lines[i]);
                                i++;
                            }
                            for (let j = 0; j < loopIterations; j++) {
                                executeLines(loopStartIndex, loopStartIndex + loopBody.length, j * 50, j * 50);
                            }
                            continue;
                        }
                    }

                    if (line.startsWith('if(')) {
                        const conditionMatch = line.match(/if\(([^)]+)\)\s*{/);
                        if (conditionMatch) {
                            ifCondition = evaluateCondition(conditionMatch[1]);
                            ifStartIndex = i + 1;
                            ifBody = [];
                            let braceCount = 1;
                            i++;
                            while (i < lines.length && braceCount > 0) {
                                if (lines[i].includes('{')) braceCount++;
                                if (lines[i].includes('}')) braceCount--;
                                if (braceCount > 0) ifBody.push(lines[i]);
                                i++;
                            }
                            if (ifCondition) {
                                executeLines(ifStartIndex, ifStartIndex + ifBody.length);
                            }
                            continue;
                        }
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'red';
                    ctx.font = '20px Arial';
                    ctx.fillText('Syntax error at line: ' + (i + 1), 10, 50);
                    return;
                }
            }

            executeLines(0, lines.length);
        }

        // Hantera kör-knappen och automatisk körning
        const codeInput = document.getElementById('codeInput');
        let debounceTimeout;
        codeInput.addEventListener('input', () => {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                runWindCode(codeInput.value);
            }, 300);
        });
        document.getElementById('runButton').addEventListener('click', () => {
            runWindCode(codeInput.value);
        });
    </script>
</body>
</html>
